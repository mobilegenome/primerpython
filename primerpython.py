#!/usr/bin/env python2.7

""" primerpython.py

A wrapper for Primer3 to automate generation of PCR primers for genomic loci.

Author: Fritjof Lammers
Email: fritjoflammers@gmail.com

"""
__author__ = 'Fritjof Lammers'
__version__ = "$Revision$"
# $Source$

from Bio import AlignIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import SeqIO
from Bio.Align import AlignInfo
# from StringIO import StringIO # deprecated ?
# from Bio.Align.Applications import MuscleCommandline # deprecated


import argparse
import subprocess32
import os
import tempfile
# VARIABLES

# MASKED_RECORD_ID = "RepeatMasked"
MASKED_RECORD_ID = "consensus"

PRIMER_TARGET = "2000,200"
PRIMER3_EXEC = "primer3/primer3_core" # path to primer3_core


default_p3_config_path = "primer3_config.orig"

p3_output = ""


def load_p3_config(fname):
    """Load Primer3 config file and saves as dictionary with KEY=VALUE allocations.
    :param fname: Path to Primer3 config file
    :return: dictionary with KEY=VALUE allocations
    """

    p3_config = {}
    with open(fname) as fin:
        for line in fin.readlines():
            split = [e.strip() for e in line.split("=") if e.strip() != ""]
            if len(split) != 2:
                continue  # Skip the last "=" line
            key = split[0]
            value = split[1]
            p3_config[key] = value

    return p3_config


def write_p3_config(config, out_fname):
    """Write Primer3 config file from dictionary
    :param config: Primer3 config dictionary as generated by load_p3_config()
    :param out_fname: Path to file to write dictionary to
    :return: True
    """

    with open(out_fname, "w") as fout:
        for key, value in sorted(config.iteritems()):
            fout.write("%s=%s\n" % (key, value))
        fout.write("=")  # Write "=" to last line

    return True


def create_p3_config(p3_config, alignment_fname):
    """Create new Primer3 config dictionary by loading existing dictionary and add / alter items.
    :param p3_config: Existing template Primer3 config dictionary.
    :param alignment_fname: Filename of alignment, to save as new config item.
    :return: New Primer3 config dictionary.
    """

    SEQUENCE_ID = alignment_fname.strip("aln.fa")  # create Sequence ID
    SEQUENCE_TEMPLATE = [record for record in alignment
                         if record.id.startswith(MASKED_RECORD_ID)][0].seq.strip(
        "-")[99:]  # Load sequence by selecting matching string

    p3_config["SEQUENCE_ID"] = SEQUENCE_ID
    p3_config["SEQUENCE_TEMPLATE"] = SEQUENCE_TEMPLATE
    p3_config["PRIMER_TARGET"] = PRIMER_TARGET

    return p3_config


def exec_p3(config_path, alignment_fname):
    """Execute Primer3
    :param config_path: Path to Primer3 config file
    :param alignment_fname: Alignment filename to generate output alignment filename
    :return: Output alignment filename
    """

    out_fname = alignment_fname.replace("aln.fa", "p3")
    print os.path.join(ALIGNMENT_IN_DIR, out_fname)
    subprocess32.call("./%s" % PRIMER3_EXEC, stdin=open(config_path),
                      stdout=open(os.path.join(ALIGNMENT_IN_DIR, out_fname), "w"))

    return out_fname


def add_primer_to_alignment(alignment_fname, p3_output_dict):
    """ Add primer sequence to alignment.
    Primer sequences are read from Primer3 output file, stored in a dictionary, written to temporary file and
    aligned to the existing alignment.

    :param alignment_fname: ALignment filename
    :param p3_output_dict: Primer3 output dictionary
    :return: Primer dictionary
    """

    primers = {}
    try:
        primers["for"] = SeqRecord(Seq(p3_output_dict.get("PRIMER_LEFT_0_SEQUENCE")),
                                   id="forward_primer", description="")
        primers["rev"] = SeqRecord(Seq(p3_output_dict.get("PRIMER_RIGHT_0_SEQUENCE")).reverse_complement(),
                                   id="reverse_primer", description="")
    except:
        return False

    i = 2
    in_alignment = os.path.join(ALIGNMENT_IN_DIR, alignment_fname)
    out_alignment = os.path.join(ALIGNMENT_IN_DIR, alignment_fname.replace("pr1", "pr%i" % i))

    for primer in primers.itervalues():
        if i == 3:
            in_alignment = out_alignment
            out_alignment = os.path.join(ALIGNMENT_IN_DIR, alignment_fname.replace("pr1", "pr%i" % i))

        with tempfile.NamedTemporaryFile() as tmp_primer: # create temporary file for primer sequence
            SeqIO.write(primer, tmp_primer.name, "fasta")  # Save primer sequence to TEMP file

            muscle_exec = "binaries/muscle3.8.425_i86linux64"  # Define muscle executable.

            muscle_call = ["%s" % muscle_exec,
                           "-profile",
                           "-out", out_alignment,
                           "-in1", in_alignment,
                           "-in2", tmp_primer.name]
            muscle_cline = subprocess32.check_call(muscle_call)
            print muscle_cline
            i += 1

    os.remove(os.path.join(ALIGNMENT_IN_DIR, alignment_fname))
    os.remove(os.path.join(ALIGNMENT_IN_DIR, alignment_fname.replace("pr1", "pr%i" % 2)))

    return primers


def generate_primers(alignment_fname):
    """Generate primers. Wrapper to combine all steps for calling Primer3.

    :param alignment_fname: Alignment input filename.
    :return: Primer dictionary if successful or False if not primer could have been generated.
    """
    global p3_output
    p3_config = load_p3_config(default_p3_config_path)  # Load template config file
    p3_config = create_p3_config(p3_config, alignment_fname)  # Create config file for loaded MSA.
    out_config_path = "%s.pry3" % default_p3_config_path  # Define path to Primer3 output config(will contain primers)
    write_p3_config(p3_config, out_config_path)  # Write new Primer3 config
    p3_output_fname = exec_p3(out_config_path, alignment_fname)  # Execute Primer3

    p3_output = load_p3_config(os.path.join(ALIGNMENT_IN_DIR, p3_output_fname))  # Load Primer3 output
    primer_dict = add_primer_to_alignment(alignment_fname, p3_output)  # Write primers to alignment.

    if primer_dict:  # Test if successfull
        return primer_dict
    else:
        return False


class WritePrimersToTable:
    """ Write Primers to tab-separated file to copy and paste into SIGMAALDRICH order sheets
    Additionally saves PrimerID - AlignmentFilename associations and save expected product size.

    """

    def __init__(self, primer_id, csv_out_fname):
        self._fout = open(csv_out_fname, "w")
        self._primer_id = primer_id

    def __del__(self):
        self._fout.close()

    def write_to_table(self, primer_dict, _alignment_fname, _product_length):
        _primer_for = primer_dict.get("for").seq
        _primer_rev = primer_dict.get("rev").reverse_complement().seq

        for _orientation in ["F", "R"]:
            _primer_seq = _primer_for if _orientation == "F" else _primer_rev
            tbl_out_str = "{0:n}_{1:s}\t{2:s}\t{3:s}\t{4:n}\n".format(self._primer_id, _orientation, _primer_seq,
                                                                      _alignment_fname, _product_length)
            self._fout.write(tbl_out_str)

        self._primer_id += 1
        return True


def main():
    global alignment
    alignment_flist = [f for f in os.listdir(ALIGNMENT_IN_DIR) if
                       os.path.isfile(os.path.join(ALIGNMENT_IN_DIR, f)) and f.endswith("aln.fa") and "pr" not in f]

    try:
        os.mkdir(os.path.join(ALIGNMENT_IN_DIR, "primerpython/"))

    except OSError:
        print("Directory ", os.path.join(ALIGNMENT_IN_DIR, "primerpython/"), " already exists")

    primer_table = WritePrimersToTable(PRIMER_NO_START, os.path.join(ALIGNMENT_IN_DIR, "primerpython/", "primer_table.csv"))
    cons_threshold = 0.95
    for alignment_fname in alignment_flist:
        alignment = AlignIO.read(os.path.join(ALIGNMENT_IN_DIR, alignment_fname), "fasta")
        summary_align = AlignInfo.SummaryInfo(alignment)

        consensus = SeqRecord(summary_align.gap_consensus(threshold=cons_threshold, ambiguous='N'),
                              id="consensus_T%i" % cons_threshold,
                              description="consensus generated by Bio.AlignInfo.dumb_consenus()")

        alignment.append(consensus)

        AlignIO.write(alignment, os.path.join(ALIGNMENT_IN_DIR, alignment_fname.replace("aln.fa", "pr1.aln.fa")),
                      "fasta")

        primer_dict = generate_primers(alignment_fname.replace("aln.fa", "pr1.aln.fa"))
        if primer_dict:
            _product_length = int(p3_output.get("PRIMER_RIGHT_0").split(",")[0]) - int(
                p3_output.get("PRIMER_LEFT_0").split(",")[0])
            primer_table.write_to_table(primer_dict, alignment_fname, _product_length)
            print "processed %s" % alignment_fname
        else:
            print "No Primers could be generated for %s" % alignment_fname
            os.remove(os.path.join(ALIGNMENT_IN_DIR, "primerpython/", alignment_fname.replace("aln.fa", "pr1.aln.fa")))
            continue

    del primer_table

    print "program closes"

    return True


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="This is pry3. A Primer3 wrapper to automatically generate"
                                                 " conserved primers quick an easy."
                                                 " \nArguments passed to the program")
    parser.add_argument('-i','--input_path',required=True, help='Folder with alignments')
    parser.add_argument('-n','--primer_start_no', type=int, required=True, help='Primer start number')

    options = parser.parse_args()

    ALIGNMENT_IN_DIR = options.input_path
    PRIMER_NO_START = options.primer_start_no
    main()


